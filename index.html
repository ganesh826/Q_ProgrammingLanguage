<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Queue Programming Language</title>
<meta name="author" content="(zookeeprr)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/blood.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">

<section>
<section id="slide-orgheadline1">
<h2 id="orgheadline1">The Queue Programming Language</h2>
<p>
A programming language to allow simple queue manipulation
</p>

<hr  />
<p>
Sam Messina
</p>

<p>
Ganesh Koripalli
</p>

<p>
Mohammed Abdulkadir
</p>

</section>
</section>
<section>
<section id="slide-orgheadline2">
<h2 id="orgheadline2">Features</h2>
<ol>
<li>Manipulate a single queue per program</li>
<li>Queue elements may be integers from 0 - 10</li>
<li>All major queue methods are implemented
<ol>
<li>Two versions of our language: compiled and interpreted</li>

</ol></li>
<li>Displays parsing and analysis data in real time as it runs</li>

</ol>

</section>
</section>
<section>
<section id="slide-orgheadline11">
<h2 id="orgheadline11">Available Methods</h2>
<div class="outline-text-2" id="text-orgheadline11">
</div></section>
<section id="slide-orgheadline3">
<h3 id="orgheadline3">ADD</h3>
<p>
ADD will add an element to the back of the queue
</p>
</section>
<section id="slide-orgheadline4">
<h3 id="orgheadline4">REMOVE</h3>
<p>
REMOVE will remove an element to the front of the queue
</p>
</section>
<section id="slide-orgheadline5">
<h3 id="orgheadline5">PEEK</h3>
<p>
PEEK will display the element at the front of the queue
</p>
</section>
<section id="slide-orgheadline6">
<h3 id="orgheadline6">LENGTH</h3>
<p>
LENGTH will display the current length of the queue
</p>
</section>
<section id="slide-orgheadline7">
<h3 id="orgheadline7">EMPTY</h3>
<ul>
<li>Boolean expression to be placed inside an IF statement.</li>
<li>Evaluates to true if the queue is empty.</li>

</ul>
</section>
<section id="slide-orgheadline8">
<h3 id="orgheadline8">NOT_EMPTY</h3>
<p>
Works like EMPTY only evaluates to true if the queue is not empty.
</p>
</section>
<section id="slide-orgheadline9">
<h3 id="orgheadline9">VIEW</h3>
<p>
Shows the queue in its current state
</p>
</section>
<section id="slide-orgheadline10">
<h3 id="orgheadline10">IF ()</h3>
<ul>
<li>Can only take EMPTY or NOT_EMPTY as an argument.</li>
<li>The line following the IF statement will be evaluated only if the IF statement is true.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgheadline12">
<h2 id="orgheadline12">BNF</h2>
<pre class="example">
&lt;line&gt;        ----&gt; &lt;expression&gt;;

&lt;expression&gt;  ----&gt; ADD &lt;element&gt; |
                    REMOVE        |
                    PEEK          |
                    LENGTH        |
                    VIEW          |
                    IF (&lt;if_expr&gt;)

&lt;if_expr&gt;     ----&gt; EMPTY         |
                    NOT_EMPTY

&lt;element&gt;     ----&gt; &lt;int&gt;

&lt;int&gt;         ----&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
</pre>

</section>
</section>
<section>
<section id="slide-orgheadline20">
<h2 id="orgheadline20">How It Works - Compiled Version</h2>
<div class="outline-text-2" id="text-orgheadline20">
</div></section>
<section id="slide-orgheadline14">
<h3 id="orgheadline14">Get The Tokens</h3>
<ol>
<li>Read in a text file to a string</li>
<li>Pass the source code string to Parser.java</li>
<li>Parser.java finds all the tokens and puts them in an array</li>
<li>The array is passed back to our main driver</li>

</ol>

</section>
<section id="slide-orgheadline13">
<h4 id="orgheadline13">Output</h4>
<pre class="example">
############## Parsing.... #################
Next token is ADD
Next token is 1
Next token is ;
Next token is ADD
Next token is 5
Next token is ;
Next token is ADD
Next token is 9
Next token is ;
Next token is ADD
Next token is 8
Next token is ;
Next token is VIEW
Next token is ;
Next token is REMOVE
Next token is ;
Next token is VIEW
Next token is ;
Next token is PEEK
Next token is ;
Next token is LENGTH
Next token is ;
Next token is VIEW
Next token is ;
Next token is IF
Next token is (
Next token is NOT_EMPTY
Next token is )
Next token is ;
Next token is VIEW
Next token is ;
Next token is IF
Next token is (
Next token is EMPTY
Next token is )
Next token is ;
Next token is VIEW
Next token is ;
</pre>

</section>
<section id="slide-orgheadline16">
<h3 id="orgheadline16">Analyze The Tokens</h3>
<p>
This stage combines token analysis and writing to "machine code" (java)
</p>
<ol>
<li>The token array is passed into LexicalAnalyzer.java</li>
<li>Instructions are converted from our language's tokens to java code to be run</li>
<li>LexicalAnalyzer writes out a string of java code to a file, including
<ol>
<li>The Queue class that will act as our Queue model for our program</li>
<li>The Main Driver for our compiled program</li>
<li>Instructions gathered from token analysis</li>

</ol></li>
<li>The new string of java code is written into output.java</li>

</ol>

</section>
<section id="slide-orgheadline15">
<h4 id="orgheadline15">Output</h4>
<pre class="example">
############## Analyzing.... #################
Next line of execution: queue.add(1);

Next line of execution: queue.add(5);

Next line of execution: queue.add(9);

Next line of execution: queue.add(8);

Next line of execution: queue.view();

Next line of execution: queue.remove();

Next line of execution: queue.view();

Next line of execution: queue.showFirst((Integer) queue.peek());

Next line of execution: queue.getLength(queue.size());

Next line of execution: queue.view();

Next line of execution: queue.view();

Next line of execution: queue.view();
</pre>

</section>
<section id="slide-orgheadline18">
<h3 id="orgheadline18">Compile The Program</h3>
<ol>
<li>output.java is compiled to output.class using Runtime.exec().</li>
<li>output.java is deleted, leaving only output.class</li>
<li>output.class acts as our executable, the output from our pseudo-compiler</li>

</ol>

</section>
<section id="slide-orgheadline17">
<h4 id="orgheadline17">Output</h4>
<pre class="example">
############## Compiling.... #################


############## Done! #################
Your file is compiled. You can run it by running: 

  java output

Happy queueing!
</pre>

</section>
<section id="slide-orgheadline19">
<h3 id="orgheadline19">Use Case Example</h3>
<pre class="example">
$ java Queue myfile.queue 
$ java output
</pre>

</section>
</section>
<section>
<section id="slide-orgheadline23">
<h2 id="orgheadline23">How It Works - Interpreted Version</h2>
<div class="outline-text-2" id="text-orgheadline23">
</div></section>
<section id="slide-orgheadline21">
<h3 id="orgheadline21">All The Steps At Once</h3>
<ul>
<li>The logic behind the interpreted version is nearly identical to that of the compiled version.</li>

<li>The major difference is the order in which everything runs</li>

<li>No more separate parsing, analyzing, compiling, and running.</li>

</ul>

</section>
<section id="slide-orgheadline22">
<h3 id="orgheadline22">The Giant Loop</h3>
<ul>
<li>Like the compiled version, our source code is translated into a string an passed to our Interpreter.java</li>

<li>Interpreter has one loop that runs through the source code, parsing, analyzing, and executing as it goes.</li>

<li>Once a token is found, it is analyzed.</li>

<li>If analysis finds an instruction to run, the instruction will be run right away.</li>

</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
