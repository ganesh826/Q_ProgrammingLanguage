<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Q Programming Language</title>
<meta name="author" content="(Sam Messina, Ganesh Koripalli, Mohammed Abdulkadir)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/blood.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">

<section>
<section id="slide-org7a95b88">
<h2 id="org7a95b88">The Q Programming Language</h2>
<p>
A programming language to allow simple queue manipulation
</p>

<hr  />

<p>
Sam Messina
</p>

<p>
Ganesh Koripalli
</p>

<p>
Mohammed Abdulkadir
</p>

</section>
</section>
<section>
<section id="slide-org870d922">
<h2 id="org870d922">Features</h2>
<ol>
<li>Manipulate a single queue per program</li>
<li>Queue elements may be integers from 0 - 10</li>
<li>All major queue methods are implemented</li>
<li>Two versions of our language: compiled and interpreted</li>
<li>Displays parsing and analysis data in real time as it runs</li>

</ol>

</section>
</section>
<section>
<section id="slide-org5dae5bf">
<h2 id="org5dae5bf">Available Methods</h2>
<div class="outline-text-2" id="text-org5dae5bf">
</div></section>
<section id="slide-orgdf38cad">
<h3 id="orgdf38cad">ADD</h3>
<p>
ADD will add an element to the back of the queue
</p>
</section>
<section id="slide-org2e82494">
<h3 id="org2e82494">REMOVE</h3>
<p>
REMOVE will remove an element to the front of the queue
</p>
</section>
<section id="slide-org96beb54">
<h3 id="org96beb54">PEEK</h3>
<p>
PEEK will display the element at the front of the queue
</p>
</section>
<section id="slide-org6ffe8d2">
<h3 id="org6ffe8d2">LENGTH</h3>
<p>
LENGTH will display the current length of the queue
</p>
</section>
<section id="slide-org9b698a4">
<h3 id="org9b698a4">EMPTY</h3>
<ul>
<li>Boolean expression to be placed inside an IF statement.</li>
<li>Evaluates to true if the queue is empty.</li>

</ul>
</section>
<section id="slide-orgee4b78a">
<h3 id="orgee4b78a">NOT_EMPTY</h3>
<p>
Works like EMPTY only evaluates to true if the queue is not empty.
</p>
</section>
<section id="slide-org71cc95f">
<h3 id="org71cc95f">VIEW</h3>
<p>
Shows the queue in its current state
</p>
</section>
<section id="slide-org9f9e250">
<h3 id="org9f9e250">IF ()</h3>
<ul>
<li>Can only take EMPTY or NOT_EMPTY as an argument.</li>
<li>The line following the IF statement will be evaluated only if the IF statement is true.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org5b57c78">
<h2 id="org5b57c78">BNF</h2>
<pre class="example">
<code>
&lt;line&gt;        ----&gt; &lt;expression&gt;;

&lt;expression&gt;  ----&gt; ADD &lt;element&gt; |
                    REMOVE        |
                    PEEK          |
                    LENGTH        |
                    VIEW          |
                    IF (&lt;if_expr&gt;)

&lt;if_expr&gt;     ----&gt; EMPTY         |
                    NOT_EMPTY

&lt;element&gt;     ----&gt; &lt;int&gt;

&lt;int&gt;         ----&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10
</code>
</pre>

</section>
</section>
<section>
<section id="slide-org39980f8">
<h2 id="org39980f8">How It Works - Compiled Version</h2>
<div class="outline-text-2" id="text-org39980f8">
</div></section>
<section id="slide-org86abf18">
<h3 id="org86abf18">Get The Tokens</h3>
<ol>
<li>Read in a text file to a string</li>
<li>Pass the source code string to Parser.java</li>
<li>Parser.java finds all the tokens and puts them in an array</li>
<li>The array is passed back to our main driver</li>

</ol>

</section>
<section id="slide-org8eef6ce">
<h4 id="org8eef6ce">Output</h4>
<pre class="example">
<code>############## Parsing.... #################
Next token is ADD
Next token is 1
Next token is ;
Next token is ADD
Next token is 5
Next token is ;
Next token is ADD
Next token is 9
Next token is ;
Next token is ADD
Next token is 8
Next token is ;
Next token is VIEW
Next token is ;
Next token is REMOVE
Next token is ;
Next token is VIEW
Next token is ;
Next token is PEEK
Next token is ;
Next token is LENGTH
Next token is ;
Next token is VIEW
Next token is ;
Next token is IF
Next token is (
Next token is NOT_EMPTY
Next token is )
Next token is ;
Next token is VIEW
Next token is ;
Next token is IF
Next token is (
Next token is EMPTY
Next token is )
Next token is ;
Next token is VIEW
Next token is ;
</code>
</pre>

</section>
<section id="slide-orgd7c2c96">
<h3 id="orgd7c2c96">Analyze The Tokens</h3>
<p>
This stage combines token analysis and writing to "machine code" (java)
</p>
<ol>
<li>The token array is passed into LexicalAnalyzer.java</li>
<li>Instructions are converted from our language's tokens to java code to be run</li>
<li>LexicalAnalyzer writes out a string of java code to a file, including
<ol>
<li>The Queue class that will act as our Queue model for our program</li>
<li>The Main Driver for our compiled program</li>
<li>Instructions gathered from token analysis</li>

</ol></li>
<li>The new string of java code is written into output.java</li>

</ol>

</section>
<section id="slide-org77920bd">
<h4 id="org77920bd">Output</h4>
<pre class="example">
<code>
############## Analyzing.... #################
Next line of execution: queue.add(1);

Next line of execution: queue.add(5);

Next line of execution: queue.add(9);

Next line of execution: queue.add(8);

Next line of execution: queue.view();

Next line of execution: queue.remove();

Next line of execution: queue.view();

Next line of execution: queue.showFirst((Integer) queue.peek());

Next line of execution: queue.getLength(queue.size());

Next line of execution: queue.view();

Next line of execution: queue.view();

Next line of execution: queue.view();
</code>
</pre>

</section>
<section id="slide-org908054b">
<h3 id="org908054b">Compile The Program</h3>
<ol>
<li>output.java is compiled to output.class using Runtime.exec().</li>
<li>output.class acts as our executable, the output from our pseudo-compiler</li>

</ol>

</section>
<section id="slide-org0f57d5b">
<h4 id="org0f57d5b">Output</h4>
<pre class="example">
<code>
############## Compiling.... #################


############## Done! #################
Your file is compiled. You can run it by running: 

  java output

Happy queueing!
</code>
</pre>

</section>
<section id="slide-org9beca71">
<h3 id="org9beca71">Use Case Example</h3>
<pre class="example">
$ java Queue myfile.queue 
$ java output
</pre>

</section>
</section>
<section>
<section id="slide-org741335c">
<h2 id="org741335c">How It Works - Interpreted Version</h2>
<div class="outline-text-2" id="text-org741335c">
</div></section>
<section id="slide-org848c26b">
<h3 id="org848c26b">All The Steps At Once</h3>
<ul>
<li>The logic behind the interpreted version is nearly identical to that of the compiled version.</li>

<li>The major difference is the order in which everything runs</li>

<li>No more separate parsing, analyzing, compiling, and running.</li>

<li>A verbose option allows users to see how to program steps through the code.</li>

</ul>

</section>
<section id="slide-org3c8cecb">
<h3 id="org3c8cecb">The Giant Loop</h3>
<ol>
<li>Like the compiled version, our source code is translated into a string.</li>
<li>The string of Q Language code is passed to our Interpreter.java</li>
<li>The Interpreter has one loop that runs through the source code, parsing, analyzing, and executing as it goes.</li>
<li>Once a token is found, it is analyzed.</li>
<li>If the analysis finds an instruction to run, the instruction will be run right away.</li>

</ol>

</section>
<section id="slide-org23e2440">
<h3 id="org23e2440">Use Case Example</h3>
<pre class="example">
$ java Queue -v myfile.queue
</pre>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
